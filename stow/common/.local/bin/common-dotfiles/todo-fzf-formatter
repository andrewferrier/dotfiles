#!/usr/bin/env python
# ruff: noqa: PLR2004

import datetime
import json
import sys
from operator import itemgetter
from typing import Final, TypedDict

import humanize
from termcolor import colored


class Entry(TypedDict):
    due: int | None
    id: str
    priority: int
    summary: str


EM_SPACE: Final[str] = "â€ƒ"  # noqa: RUF001

data: list[Entry] = json.load(sys.stdin)

current_timezone = datetime.datetime.now().astimezone().tzinfo

now_time = datetime.datetime.now(tz=current_timezone)
now_date = now_time.date()


def is_time_agnostic(timestamp: int) -> bool:
    due_time_naive_check = datetime.datetime.fromtimestamp(timestamp)  # noqa: DTZ006
    return (
        due_time_naive_check.hour == 0
        and due_time_naive_check.minute == 0
        and due_time_naive_check.second == 0
    )


def is_due_within_date_window(
    due_date: datetime.date, now_date: datetime.date, near_days: int, far_days: int
) -> bool:
    date_difference: datetime.timedelta = due_date - now_date
    return (
        due_date > now_date
        and date_difference < datetime.timedelta(days=far_days)
        and date_difference > datetime.timedelta(days=near_days)
    )


def due_date_key_func(entry: Entry) -> int:
    if entry["due"] is None:
        # Assign a very large value for items with no due date,
        # ensuring they are sorted last when `reverse=True` is used.
        return 9999999999999
    else:
        original_due_timestamp = entry["due"]

        if is_time_agnostic(original_due_timestamp):
            # If time-agnostic, adjust its time component to now_time for
            # sorting purposes. This ensures items due "today" with no specific
            # time are treated as due now, and past time-agnostic items are
            # treated as due at the equivalent time in the past.

            original_due_time = datetime.datetime.fromtimestamp(
                original_due_timestamp, tz=current_timezone
            )
            adjusted_due_time = datetime.datetime.combine(
                original_due_time.date(), now_time.time(), tzinfo=current_timezone
            )
            return int(adjusted_due_time.timestamp())
        else:
            return original_due_timestamp


data = sorted(data, key=itemgetter("summary"))
data = sorted(data, key=due_date_key_func, reverse=True)

for entry in data:
    datecolor: str = "light_grey"
    entrycolor: str = "white"
    human_date: str

    if entry["priority"] > 0 and entry["priority"] < 4:
        entrycolor = "red"
    elif entry["priority"] >= 4 and entry["priority"] < 7:
        entrycolor = "yellow"
    elif entry["priority"] >= 7 and entry["priority"] <= 9:
        entrycolor = "blue"

    if entry["due"] is None:
        human_date = ""
    else:
        due_time: datetime.datetime = datetime.datetime.fromtimestamp(
            entry["due"], tz=current_timezone
        )
        due_date: datetime.date = due_time.date()

        human_date: str = humanize.naturalday(due_date, format="%Y-%m-%d")

        if is_time_agnostic(entry["due"]):
            if now_date > due_date:
                datecolor = "red"
            elif now_date == due_date:
                datecolor = "green"
        else:
            human_date = f"{human_date} {due_time.strftime('%H:%M')}"

            if now_time > due_time:
                datecolor = "red"

        if is_due_within_date_window(due_date, now_date, 1, 7):
            human_date = due_date.strftime("%A")

    summary_to_print = entry["summary"].replace("\n", "\\n").replace("\r", "\\r")

    print(  # noqa: T201
        f"{entry['id']:5}{EM_SPACE}"
        + colored(f"{human_date:14}{EM_SPACE}", datecolor, force_color=True)
        + colored(f"{summary_to_print}", entrycolor, force_color=True)
    )
